import math
import numpy


# Calculates a and b for the decision equation
# generated by case 1 of the form y = ax + b
def case_1_equation(mu0, mu1, var, p0=0.5, p1=0.5):
    a = (mu0[0] - mu1[0]) / (mu1[1] - mu0[1])
    b_term1 = (mu1[1]**2 + mu1[0]**2 - mu0[1]**2 - mu0[0]**2) / (2.0 * (mu1[1] - mu0[1]))
    b_term2 = (var * (math.log(p0) - math.log(p1))) / (mu1[1] - mu0[1])
    b = b_term1 + b_term2
    return a, b


# Calculates a and b for the decision equation
# generated by case 2 of the form y = ax + b
def case_2_equation(mu0, mu1, var, p0=0.5, p1=0.5):
    inv_var = numpy.linalg.inv(var)

    q = -2.0 * mu0[0] * inv_var[0, 0] \
        - mu0[1] * inv_var[1, 0] \
        - mu0[1] * inv_var[0, 1] \
        + 2.0 * mu1[0] * inv_var[0, 0] \
        + mu1[1] * inv_var[1, 0] \
        + mu1[1] * inv_var[0, 1]

    l = mu0[0]**2 * inv_var[0, 0] \
        + mu0[0] * mu0[1] * inv_var[1, 0] \
        + mu0[0] * mu0[1] * inv_var[0, 1] \
        + mu0[1]**2 * inv_var[1, 1] \
        - mu1[0]**2 * inv_var[0, 0] \
        - mu1[0] * mu1[1] * inv_var[1, 1] \
        - mu1[0] * mu1[1] * inv_var[0, 1] \
        - mu1[1]**2 * inv_var[1, 1]

    r = -1.0 * mu0[0] * inv_var[1, 0] \
        - mu0[0] * inv_var[0, 1] \
        - 2.0 * mu0[1] * inv_var[1, 1] \
        + mu1[0] * inv_var[1, 0] \
        + mu1[0] * inv_var[0, 1] \
        + 2.0 * mu1[1] * inv_var[1, 1]

    a = -q / r
    b = -l / r + (2.0 / r) * (math.log(p0) - math.log(p1))

    return a, b


# Calculates the plottable x, y pairs
# for the decision equation generated by case 3.
def case_3_equation(mu0, mu1, var0, var1, p0=0.5, p1=0.5):

    x1s = []
    y1s = []

    x2s = []
    y2s = []

    inv_var0 = numpy.linalg.inv(var0)
    inv_var1 = numpy.linalg.inv(var1)

    v0 = v(mu0, inv_var0)
    v1 = v(mu1, inv_var1)
    h0 = h(mu0, inv_var0, var0, p0)
    h1 = h(mu1, inv_var1, var1, p1)

    a = 0.5 * (inv_var1[1, 1] - inv_var0[1, 1])

    for x in numpy.arange(-2, 2, 0.0001):

        b = v0[0][1] - v1[0][1] \
            + 0.5 * x * (inv_var1[1, 0] + inv_var1[0, 1]
                         - inv_var0[1, 0] - inv_var0[0, 1])

        c = 0.5 * x**2 * (inv_var1[0, 0] - inv_var0[0, 0]) \
            + x * (v0[0][0] - v1[0][0]) \
            + h0 - h1

        y_roots = numpy.roots([a, b, c])
        y1 = y_roots[0]
        y2 = y_roots[1]

        if y1.imag == 0.0:
            x1s.append(x)
            y1s.append(y1)

        if y2.imag == 0.0:
            x2s.append(x)
            y2s.append(y2)

    return x1s, y1s, x2s, y2s


def v(mu, inv_var):
    v = numpy.transpose(numpy.dot(inv_var, mu))
    return v


def h(mu, inv_var, var, p):
    h = -0.5 * numpy.dot(numpy.dot(numpy.transpose(mu), inv_var), mu)
    h -= 0.5 * math.log(numpy.linalg.det(var))
    h += math.log(p)
    return h
